<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ywq1113.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="My Personal Blog">
<meta property="og:url" content="http://ywq1113.github.io/index.html">
<meta property="og:site_name" content="My Personal Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yangwq">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://ywq1113.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-cn'
  };
</script>

  <title>My Personal Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">My Personal Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/06/19/CSAPP%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/19/CSAPP%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" class="post-title-link" itemprop="url">CSAPP优化程序性能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-19 16:49:06 / Modified: 16:57:47" itemprop="dateCreated datePublished" datetime="2020-06-19T16:49:06+08:00">2020-06-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="优化程序性能"><a href="#优化程序性能" class="headerlink" title="优化程序性能"></a>优化程序性能</h1><p>来源于CSAPP第五章</p>
<h2 id="消除不必要的内存引用"><a href="#消除不必要的内存引用" class="headerlink" title="消除不必要的内存引用"></a>消除不必要的内存引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以设计不同的数据类型来测量程序性能</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">data_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> len;</span><br><span class="line">    <span class="keyword">data_t</span> *data;</span><br><span class="line">&#125; vec_rec, *vec_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设计对数据执行不同的运算</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDENT 0  <span class="comment">//求和，如果是求乘积设为1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OP +  <span class="comment">//如果求乘积设为*</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combin3</span><span class="params">(vec_ptr v, <span class="keyword">data_t</span>* dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">long</span> length = vec_length(v);  <span class="comment">//减少循环中的函数调用</span></span><br><span class="line">    <span class="keyword">data_t</span>* data = get_vec_start(v);  <span class="comment">//减少过程调用的优化</span></span><br><span class="line"></span><br><span class="line">    *dest = IDENT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        *dest = *dest OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的汇编码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># vmovsd代表从指定的位置读数据</span><br><span class="line">.L17:                    # loop:</span><br><span class="line">vmovsd  (%rbx), %xmm0    # Read product from dest          指针dest的地址从%xmm0读出来，存在寄存器%rbx中</span><br><span class="line">vmulsd  (%rdx), %xmm0    # Multiply product by data[i]     第i个元素的指针保存在%rdx中</span><br><span class="line">vmovsd  %xmm0, (%rbx)    # Store product at dest           将rbx中的数据读出，存入%xmm0中</span><br><span class="line">addq    $8, %rdx         # Increment data + i</span><br><span class="line">cmpq    %rax, %rdx       # Compare to data+length          data+length存放在%rax中</span><br><span class="line">jne     .L17             # If !&#x3D;, goto loop</span><br></pre></td></tr></table></figure>

<p>进入循环后，从内存中读数据，和<code>data[i]</code>乘，再写入到内存中。这种操作比较浪费，因为循环下次读的数据是上次写入内存的数据。</p>
<p>可以用一个临时变量来存储结果，等循环结束后再写入内存中。这样每次循环可以减少一次写的过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combin4</span><span class="params">(vec_ptr v, <span class="keyword">data_t</span>* dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">long</span> length = vec_length(v);  </span><br><span class="line">    <span class="keyword">data_t</span>* data = get_vec_start(v);  </span><br><span class="line">    <span class="keyword">data_t</span> acc = IDENT;  <span class="comment">//temp variable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *data = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，从代码层面看指令是一条一条执行的，但是实际处理器中是同时对多条指令求值，这种现象称为指令级并行。所以这两种操作限制了程序的瓶颈：第一个是指令必须按照严格顺序执行，那就会遇到延迟界限；第二个是吞吐量界限（取决于处理器原始计算能力）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/06/09/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%BF%BD%E8%B8%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/09/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%BF%BD%E8%B8%AA/" class="post-title-link" itemprop="url">Linux高并发服务器内存泄漏追踪转载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-09 22:43:24 / Modified: 22:46:31" itemprop="dateCreated datePublished" datetime="2020-06-09T22:43:24+08:00">2020-06-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>看了一篇博客，个人感觉很有帮助，目前转载过来留存，正在征询作者意见，如果不同意就删掉啦。</p>
<p>原文链接：<a href="https://blog.csdn.net/kenanxiuji/article/details/48547285" target="_blank" rel="noopener">https://blog.csdn.net/kenanxiuji/article/details/48547285</a></p>
<p>最近，我一直忙于追踪分析，咱公司高并发代理服务器内存一直占用过高的问题。该问题表现如下，使用python脚本压测，服务器使用的物理内存一直飙升很快上G、虚拟内存更是高达数10G，没有下降的趋势。当压测程序停止运行后，整个服务占用的物理内存以及虚拟内存并没有下降的趋势。</p>
<p>首先简诉咱服务器运行的平台是centos-6.3（linux-2.6.32），该服务器是多进程的，基于libevent网络通信框架，以bufferevent为核心，并使用google::protobuf通信协议进行数据传输。</p>
<p>根据top -p /pmap -dx 等命令，检测出咱服务器进程内存占用很高，我揣测产生了内存泄露。内存泄露有两种，第一种是进程一直持有不在需要或者使用的内存，这不是狭义的内存泄露，因为没有野指针的产生，可以归为广义的内存泄露，这是危害最大的，也是很难捕捉的内存泄露，使用valgrind等工具是没有办法检测出来的；第二种是进程通过malloc、new分配了堆内存，却由于各种原因，未能释放，这是狭义的内存泄露，可以通过valgrind等内存泄露工具检测到的。</p>
<p>首先，我采用valgrind进行内存泄露检测。的确发现了部分内存泄露，不过只有数10M，这个和top -p/pmap -dx等命令看出的内存实际使用情况不符。因此基本排除了上面提到的第二种内存泄露引起的。缺少了内存泄露检测工具的帮助，想要解决这个问题如同大海捞针。我开始怀疑第一种内存泄露造成的。如何定位呢？只能采用二分法，在程序的关键节点设置检测点，注释无关代码等手段逐一排查。</p>
<p>咱使用了protobuf通信协议，有同事提出是不是protobuf协议的误用，造成内存堆积呢？我的确在网上找到了有关protobuf的误用造成的内存堆积的案例。原因如下，为了提升服务器的性能，避免内存碎片，protobuf消息对象使用后，就直接缓存起来，当下次使用的时候，直接从对象池中取出，并调用了clear()函数，然后再进行构造新的消息。在这个过程中，protobuf并没有因为调用了clear()函数，而释放持有的内存，其实根本没有释放任何内存，而是递归调用，恢复成员为默认值。如果一个小对象复用了之前的大对象，这个时候内存并没有紧缩，仍然持有大对象所占有的内存，这样的确会浪费大量的空间。不过，由于咱服务器对象池最多缓存1024个对象，获取对象的时候从池中弹出，完成使用后又放回池中。这个过程是动态的，因此对象池中的对象总是在变，也就是内存是弹性的，可伸缩的理论上不会成为问题。在压测过程中，使用的测试数据包不超过1M，基本可以推断，这不是问题。不过，为了证实我的推论，我采用定时清空对象池，或者压根不缓存protobuf对象两种方式，不幸的是，内存仍然上涨。</p>
<p>兄弟，还是老实点吧！只能从数据的流动方向开始追踪问题。</p>
<p>第一步检测网络通信框架收发数据是否会产生大量的内存占用？可以通过bufferevent获取当前输入缓冲区的可读数据的字节长度，一旦libevent通知用户有数据可读，就将缓冲区中的所有数据抽出，尽可能的保证bufferevent缓冲区中没有堆积数据。效果很明显，内存几乎没有上涨。对数据的处理几乎没有延时，基本可以认为是malloc以后立马就释放。</p>
<p>第二步检测协议解析是否产生内存泄露？数据完成解析后，就直接将这部分数据抽取出去，并立即返回。我在做这个实验的过程中，我出现了逻辑失误，本意是希望不停的从evbuffer中取出数据进行解析，直到evbuffer中的剩余数据不能完整构成协议。事实是libevent每通知一次有数据可读，我就从evbuffer中取出一个数据进行解析，这样就造成了数据堆积在bufferevent缓冲区。原因是多个数据同时到达TCP接收缓冲区，这时epoll感知到某连接有可读数据，就立刻通知libevent，libevent处理可读事件，从TCP缓冲区接收完数据（可能由多个消息组成的）后，调用咱服务器注册的读回调函数，不过，我们在读回调函数里面只取了一个消息，最终bufferevent中会堆积大量的数据，占用大量的内存。当连接断开后，libevent应该会释放bufferevent占用的内存，然而内存并没有显著下降。感觉十分诡异，难道valgrind没有检测出内存泄露？重新调整了测试逻辑，保证向libevent注册的读回调函数，循环读取数据，直到不是一个完整的协议为止。这种测试比第一步的测试仅仅多了协议解析，测试结果显示内存基本没有增长，也基本排除了数据解析造成内存泄露的可能。</p>
<p>第三步在第二步中不小心做的一次读回调，只解析一个数据的测试，造成大量数据堆积在evbuffer中，当连接断开后，内存竟然下降不明显。为了更加充分的暴露这个现象，我决定再做一次测试——压测脚本不停的发数据，服务端什么也不做，当压测结束的时候，所有的数据都应该堆积在evbuffer中，然而当连接断开后，服务器进程占用的物理内存并没有下降。难道是libevent没有感知到部分连接已经断开的事实？这样内存还堆积在libevent中，而且libevent在退出的时候，还能正确释放这些内存，因此valgrind就检测不出来，这个推断看上去比较合理。如何证明libevent是否是清白的呢？似乎进入死胡同，暂时放一放，继续朝下走。</p>
<p>第四步检测protobuf对象以及状态机对象的构造是否会造成内存泄露？协议解析完成后，经过简单的逻辑处理，就生成protobuf对象和状态机对象，然后立刻delete。内存仍然没有增长，基本可以排除protobuf的嫌疑。</p>
<p>以此类推，逐一排查，有点像刑侦破案一样。后来终于发现了一个可疑点。当注释SendRequest函数后，整个进程占用的内存几乎没有增长。重点就放在了这个函数上，进入该函数后，粗一看，没发现什么问题。这个函数就干一件事，把protobuf的消息转换成evbuffer，以零拷贝的方式把数据加入到bufferevent的输出缓冲区。就几行代码，没有什么不妥啊，有点发愣。把数据加入到libevent以后，竟然会出现内存上涨的现象。我开始怀疑是不是哪里测试错了呢？干扰了判断呢？经过好几次测试后，我基本断定就是这里出了问题。又该如何去定位呢？这么成熟的网络通信库，怎么会出问题呢？</p>
<p>为了搞清楚bufferevent使用内存的情况，我开始剖析libevent库，给这个库增加接口，包括获取buffer当前的引用计数，获取bufferevent当前的引用计数，获取当前buffer实际分配的内存大小，获取当前buffer实际分配的chain的个数等，在与内存分配与释放相关的函数中增加了文件日志。bufferevent把数据存储在evbuffer中，而evbuffer是由evbuffer_chain链表构成，很显然evbuffer_chain的分配总量就能大致体现出整个网络通信的数据总流量，另外，统计一下evbuffer_chain的释放总量，根据分配总量和释放总量就能证明libevent的清白。为了做到这点，为evbuffer_chain_new和evbuffer_chain_free增加了统计总量的逻辑。</p>
<p>首先我根据evbuffer_chain_new与evbuffer_chain_free的分配与释放总量的统计，显示出libevent分配的内存总量与释放的内存总量相等，足以证明libevent是清白的。明明释放了内存，为什么没有看到进程的内存使用量下降呢？感觉十分诡异！！！另外，我通过获取当前buffer实际分配的内存大小与实际使用的内存大小，不看不知道，一看吓一跳，evbuffer分配的空间远远超过了实际数据所需的大小。通过查看代码发现，由protobuf转换成evbuffer的时候，默认指定128k的分配空间，不管数据本身有多大，不过，evbuffer分配的chain不是128k，而是256k?我认真阅读了libevent源码后发现，在64位操作系统上，是按照1k的默认大小做逻辑左移，由于咱指定128k,不过还得加上chain本身的大小，也就是超过128k,这样只能对1k左移8次也就是256k。正是由于这个原因造成了内存的使用率极其低下，当网络拥塞的时候，或者通信双方的处理速度差过大的时候，就会出现大量的数据堆积在bufferevent中，我统计过拥塞较大时，bufferevent中缓存了高达15000个chain，而每个chain又是256k，这个累积量就高达3.6G的虚拟内存，而实际有效载荷才29.2M，正如top -p显示的，DATA段远远大于RES段。通过tcpdump抓包显示proxy（本服务）与storage（后端服务）通信的连接，本来是长连接，不过在这种高压环境下，出现了大量的断开、重连的现象，而且都是响应RST，显然这条连接不够问题，是否和虚拟网络相关呢？由于连接频繁的断开，libevent会迅速的回收释放的资源，不过，这样也会加剧内存碎片。</p>
<p>现象基本描述完咯，感觉还是一头雾水，问题出在哪里呢？首先，我基本排除了有大量内存堆积或者泄露（狭义的），因为内存消耗最大的一定是libevent，毕竟所有的数据的传输都依赖libevent，而根据统计显示，libevent分配了多少内存，最终的完全释放了，其他的内存消耗都是不会出现内存堆积的。其次，虚拟内存飙升到数10G的原因是比较明确的，就是服务进程分配了大量未使用的内存，就是前面提到的由protobuf转换成evbuffer的时候，没有根据数据本身的大小进行内存分配所致，至于为什么没有降下来，还是不确定。</p>
<p>不得不回到前面提到的内存已经释放，为什么top -p出来的内存使用量没有下降呢？调用free就应该把由malloc申请的内存归还给操作系统，有错吗？通过网上查询得知，我对free的认识是错误的，由于free是由glibc库提供的，而glibc默认采用ptmalloc进行内存的分配。ptmalloc为了提升性能，不会立刻把内存归还给操作系统，归还给操作系统的条件是很苛刻的。毕竟，与系统底层通信的代价是昂贵的，如果动辄就直接操纵大量小块内存，就相当于频繁地与系统调用进行通信，这样显然会降低程序的运行效率。将小块内存放入brk维护的一个堆中，就相当于实现了一块缓存（cache），用完了可以先攒起来，到时候可以一起归还给系统。不过，由于它的实现相对来说还是比较简单，只维护了堆顶的一个指针。因此想要归还给系统的话，必须从顶向下，依次归还。想象一下这种情况，假如堆顶有块内存一直被占用着，而下面的所有内存都已经没用了。那下面的这些内存，可以归还给系统吗？很遗憾，这种设计决定了答案是不可以。这就出现了“洞（Hole）”的问题。</p>
<p>问题已经水落石出，不过，还是没有十足的把握，毕竟没有直接证据呢？还好glibc提供了一个malloc_trim()这个函数，头文件是<code>&lt;malloc.h&gt;</code>，这个函数将会重新整理内存，释放符合条件的已经归还给glibc，但未归还给操作系统的内存。为了证实推论，我把malloc_trim(0)放入信号处理函数中，当压测程序结束运行之后，待cpu使用率为0.0%的时候，我触发了一个信号。内存奇迹般的下降了，以下是真是测量数据（去原文找，图就不放了）</p>
<p>物理内存的降幅十分明显，至于虚拟内存为什么没有释放，可能和malloc_trim的工作原理相关。</p>
<p>总而言之，想要根治这类问题，就需要在应用层使用内存池，避免频繁使用malloc与free，这种由于glibc的原因造成的内存泄露，十分隐蔽，希望有类似问题困扰的读者不妨可以试一试。</p>
<p>————————————————<br>版权声明：本文为CSDN博主「禾田八久」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://blog.csdn.net/kenanxiuji/article/details/48547285" target="_blank" rel="noopener">https://blog.csdn.net/kenanxiuji/article/details/48547285</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/06/09/CentOS7%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5mysqlclient/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/09/CentOS7%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5mysqlclient/" class="post-title-link" itemprop="url">CentOS7无法连接mysqlclient</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-09 18:46:33 / Modified: 18:52:35" itemprop="dateCreated datePublished" datetime="2020-06-09T18:46:33+08:00">2020-06-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在makefile中用了<code>-lmysqlclient</code>,但是会报错<code>/usr/bin/ld: cannot find -lmysqlclient</code>。</p>
<p>先在/user/lib中查，发现没有，用find / -name mysqlclient发现也没有。</p>
<p>于是借助搜索引擎去查，结果国内论坛怎么也没找到解决办法，不得已去看官方C API，发现让重新下载解压，遂放弃。</p>
<p>随后又在stack overflow搜索了一下，果不其然，成功解决。附上解决方案：<a href="https://stackoverflow.com/questions/15958612/libmysqlclient-a-is-nowhere-to-be-found" target="_blank" rel="noopener">https://stackoverflow.com/questions/15958612/libmysqlclient-a-is-nowhere-to-be-found</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/06/08/%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/08/%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/" class="post-title-link" itemprop="url">缓存读写一致性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-08 17:54:22 / Modified: 17:57:26" itemprop="dateCreated datePublished" datetime="2020-06-08T17:54:22+08:00">2020-06-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="缓存读写一致性问题"><a href="#缓存读写一致性问题" class="headerlink" title="缓存读写一致性问题"></a>缓存读写一致性问题</h1><p>在知乎看（搜索）到这么一个问题：如何用redis/memcache做Mysql缓存层？刚好最近学的项目只是用到了mysql，这里学习整理一下缓存的知识。PS：强烈建议学习陈皓大神的文章以及阅读英文原文，中文博客知识需要进行筛选。</p>
<p>知乎问题<a href="https://www.zhihu.com/question/27738066" target="_blank" rel="noopener">https://www.zhihu.com/question/27738066</a></p>
<p>陈皓(左耳朵耗子)的文章<a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">https://coolshell.cn/articles/17416.html</a></p>
<p>首先要讨论的是，缓存删除还是更新的问题。<strong>什么情况下选择删除，什么情况下选择更新</strong>？</p>
<ul>
<li><p>缓存存储的value是序列化的对象</p>
<p>  序列化和反序列化需要消耗cpu的资源，删除缓存成本更低，等出现下次数据汇源时再更新。</p>
</li>
<li><p>高并发的场景</p>
<p>  两个并发操作，一个查询缓存，一个更新操作。先更新（选择删除缓存），再查询，此时无法命中缓存，会先把老的数据从数据库读出放入缓存中，然后更新数据库。此时缓存中是脏的数据，并且一直这样脏下去。所以，这种场景应该选择缓存更新，而不是删除Cache后再从数据库更新。</p>
</li>
</ul>
<h2 id="更新缓存的四种模式"><a href="#更新缓存的四种模式" class="headerlink" title="更新缓存的四种模式"></a>更新缓存的四种模式</h2><h3 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h3><p>缓存预留模式，最常用的模式之一。这种模式的重点在于先把数据更新到数据库，成功后让缓存失效，最后更新缓存。</p>
<p>在并发的情况下，更新前查询缓存命中，此时是老数据，更新过程中查询只有两种情况：1）更新过程中命中缓存，获取脏数据，之后再查询都是新的数据；2）更新后让缓存失效，此时查询无法命中缓存，直接从数据库获取新的数据。</p>
<p>这样不会出现上面谈到的缓存中总是脏数据的逻辑问题。但是也不代表这种做法是稳定安全的。如果在读数据的过程没有命中缓存，同时有一个并发写的操作，读操作从数据库得到脏数据，数据库更新，之前的读操作再把老的数据放进去，就会造成脏数据。</p>
<p>总结：Facebook采用这种做法，是选择将脏数据概率降至最低，而不是选择成本较高的2PC和Paxos分布式一致性协议保证数据的一致性。</p>
<h3 id="Read-Write-Through-Pattern"><a href="#Read-Write-Through-Pattern" class="headerlink" title="Read/Write Through Pattern"></a>Read/Write Through Pattern</h3><p>Read/Write through模式（直写模式）是把更新数据库的操作，交给缓存，认为后端是一个单一的存储，这个存储维护自己的Cache，对应用层很友好。</p>
<p>缺点：相比write back模式，数据修改时同时写入数据库，写入速度慢。</p>
<ul>
<li><p><strong>Read Through</strong></p>
<p>  在查询/读操作中更新缓存，缓存失效时服务自己从数据库中加载。</p>
</li>
<li><p><strong>Write Through</strong></p>
<p>  和Read Through相仿，区别在于是在更新/写数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）。</p>
</li>
</ul>
<h3 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h3><p>也称作write back回写模式。在数据更新时只写入缓存Cache。只有数据被替换出缓存时，被修改的缓存数据才会写到后端存储。</p>
<p>优点：写入速度快，不需要同步写到数据库中；异步操作也可以合并对同一个数据的多次操作，提高性能。</p>
<p>缺点：一旦更新后的数据未被写入存储时，出现系统断电的现象，数据无法找回。</p>
<p>write back流程图：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20200608/569886209_1591610186458_4A47A0DB6E60853DEDFCFDF08A5CA249" alt="图片说明" title="图片标题"> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/06/08/unordered-map%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/08/unordered-map%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">unordered_map使用自定义键类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-08 16:26:51 / Modified: 16:28:32" itemprop="dateCreated datePublished" datetime="2020-06-08T16:26:51+08:00">2020-06-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="unordered-map定义-C-11"><a href="#unordered-map定义-C-11" class="headerlink" title="unordered_map定义(C++11)"></a>unordered_map定义(C++11)</h1><p><a href="https://blog.csdn.net/y109y/article/details/82669620#3.1" target="_blank" rel="noopener">参考博客</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Hash</span> = <span class="title">std</span>:</span>:hash&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">KeyEqual</span> = <span class="title">std</span>:</span>:equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> Key, T&gt; &gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">unordered_map</span>;</span></span><br></pre></td></tr></table></figure>

<p>Key代表键值（key），T是根据哈希函数得到的值（value），Hash是哈希函数的函数对象，KeyEqual是等比函数的函数对象，通过<code>&quot;==&quot;</code>来判断两个key是否相等。<br>想实现自定义的键类型，必须实现hash函数和等比函数。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>法一：利用std::function中的默认hash函数std::hash</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mypair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> first;</span><br><span class="line">    <span class="keyword">char</span> second;</span><br><span class="line"></span><br><span class="line">    mypair(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( a &lt; b)</span><br><span class="line">        &#123;</span><br><span class="line">            first = a;</span><br><span class="line">            second = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            first = b;</span><br><span class="line">            second = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> mypair&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs.first == <span class="keyword">this</span>-&gt;first &amp;&amp; rhs.second == <span class="keyword">this</span>-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">mypair_hash</span><span class="params">(<span class="keyword">const</span> mypair&amp; tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash&lt;<span class="keyword">char</span>&gt;()(tmp.first) ^ hash&lt;<span class="keyword">char</span>&gt;()(tmp.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ERRO: unordered_map&lt;mypair, int, decltype(&amp;mypair_hash)&gt; ids;</span></span><br><span class="line">    <span class="comment">//ERRO: unordered_map&lt;mypair, int, mypair_hash&gt; ids(100, mypair_hash );</span></span><br><span class="line">    <span class="comment">//OK: unordered_map&lt;mypair, int, decltype(&amp;mypair_hash)&gt; ids(100, mypair_hash );</span></span><br><span class="line">    unordered_map&lt;mypair, int, decltype(&amp;mypair_hash)&gt; memo(20/*, mypair_hash*/);  //在这里decltype后面必须要使用引用</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * code</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<p>1) decltype(exp)推导的内容如果是一个左值，那么 decltype(exp) 的类型就是 exp 的引用。在这里mypair_hash是一个函数，如果是自动推导得到的是函数的返回值，不是引用类型，运行时编译器会报错，在hashtable_policy.h中：<br><code>field &#39;std::__detail::_Hashtable_ebo_helper&lt;1, long long unsigned int(const mypair&amp;), false&gt;::_M_tp&#39; invalidly declared function type</code></p>
<p>2) 参考的博客中说memo初始化时必须传入mypair_hash构造函数，但是我尝试不传入发现也是可以编译通过和运行的。</p>
<ul>
<li>法二：重载operator()类，打包哈希函数变成函数对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mypair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> first;</span><br><span class="line">    <span class="keyword">char</span> second;</span><br><span class="line"></span><br><span class="line">    mypair(<span class="keyword">const</span> <span class="keyword">char</span>&amp; a, <span class="keyword">const</span> <span class="keyword">char</span>&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        first = a;</span><br><span class="line">        second = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> mypair&amp; rhs) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs.first == first &amp;&amp; rhs.second == second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashname</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> mypair&amp; tmp)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (hash&lt;<span class="keyword">char</span>&gt;()(tmp.first)) ^ (hash&lt;<span class="keyword">char</span>&gt;()(tmp.second));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_map&lt;mypair, int, hashname&gt; memo(20);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * code</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以直接运行通过，没有什么坑。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/05/24/malloc%E5%92%8Calloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/24/malloc%E5%92%8Calloc/" class="post-title-link" itemprop="url">malloc和alloc</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-24 21:33:33 / Modified: 21:53:53" itemprop="dateCreated datePublished" datetime="2020-05-24T21:33:33+08:00">2020-05-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="malloc和alloc"><a href="#malloc和alloc" class="headerlink" title="malloc和alloc"></a>malloc和alloc</h1><p>在网上找到的转载的英文资料，附上自己的一些理解<a href="https://blog.csdn.net/missuever/article/details/540045" target="_blank" rel="noopener">点击连接</a></p>
<p>Both the <code>malloc()</code> and the <code>calloc()</code> functions are used to allocate dynamic memory. Each operates slightly different from the other.</p>
<p>malloc和calloc函数都用来分配动态内存，他们之间的差别很小</p>
<p><code>malloc()</code> takes a size and returns a pointer to a chunk of memory at least that big: </p>
<p><code>void *malloc( size_t size );</code></p>
<p>malloc返回至少有申请内存大小的一块内存（可能更大）</p>
<p><code>calloc()</code> takes a number of elements, and the size of each, and returns a pointer to a chunk of memoryat least big enough to hold them all:</p>
<p><code>void *calloc( size_t numElements, size_t sizeOfElement );</code></p>
<p>calloc返回至少有多块内存大小之和的内存（可能更大）</p>
<p>There are one major difference and one minor difference between the two functions. The major difference is that <code>malloc()</code> does not initialize the allocated memory. The first time <code>malloc()</code> gives you a particular chunk of memory, the memory might be full of zeros. If memory has been allocated, freed, and reallocated, it probably has whatever junk was left in it. That means, unfortunately, that a program might run in simple cases (when memory is never reallocated) but break when used harder (and when memory is reused).</p>
<p>他们之间最主要的差别是，malloc不初始化分配的内存，可能内存中充满的是零。如果内存已经被分配、释放或重新分配过，它可能存放着未知的内容。这意味着当这块内存从申请，修改，再到被重新分配，包含未知的内容会导致程序崩溃</p>
<p><code>calloc()</code> fills the allocated memory with all zero bits. That means that anything there you are going to use as a char or an int of any length, signed or unsigned, is guaranteed to be zero. Anything you are going to use as a pointer is set to all zero bits. That is usually a null pointer, but it is not guaranteed.Anything you are going to use as a float or double is set to all zero bits; that is a floating-point zero on some types of machines, but not on all.</p>
<p>calloc()用0 bits填充分配的内存，所以不需要初始化。通常这是一个空指针，但并不保证一定是。使用float或double类型被置为zero bits，在某些机器上是浮点零，但不保证一定是。</p>
<p>The minor difference between the two is that <code>calloc()</code> returns an array of objects; <code>malloc()</code> returns one object. Some people use <code>calloc()</code> to make clear that they want an array.</p>
<p>一些细小差别是calloc()返回一个包含对象的数组，而malloc返回一个对象。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/05/09/muduo%E5%BA%93%E6%BA%90%E7%A0%81Buffer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/09/muduo%E5%BA%93%E6%BA%90%E7%A0%81Buffer/" class="post-title-link" itemprop="url">muduo库源码Buffer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-09 15:12:25" itemprop="dateCreated datePublished" datetime="2020-05-09T15:12:25+08:00">2020-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-14 12:50:30" itemprop="dateModified" datetime="2020-05-14T12:50:30+08:00">2020-05-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Buffer的功能需求"><a href="#Buffer的功能需求" class="headerlink" title="Buffer的功能需求"></a>Buffer的功能需求</h1><p>设计buffer可以从易用性和性能两方面考虑，muduo的buffer更偏向于易用性。</p>
<ul>
<li>对外表现是一块连续的内存<code>(char* p, int len)</code></li>
<li>其<code>size()</code>可以自动增长，不是固定大小的数组</li>
<li>内部以<code>std::vector&lt;int&gt;</code>来保存数据</li>
<li>buffer更像一个queue，从尾部写入数据，从头部读取数据</li>
<li><code>input buffer</code>：连接从socket中读取数据，写入<code>input buffer</code>；客户代码从中读取数据</li>
<li><code>output buffer</code>：客户代码把数据写入<code>output buffer</code>，连接从<code>output buffer</code>中读数据并写入socket</li>
</ul>
<h1 id="muduo-base基础库"><a href="#muduo-base基础库" class="headerlink" title="muduo/base基础库"></a>muduo/base基础库</h1><p>在学习muduo如何实现Buffer之前，先阅读<code>Buffer.h</code>头文件中所需要的依赖。</p>
<h2 id="types-h"><a href="#types-h" class="headerlink" title="types.h"></a>types.h</h2><p>基本类型的声明，如<code>muduo::string</code>；<br>具体有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">memZero</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为static_cast&lt;&gt;或const_cast&lt;&gt;的安全版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> To, <span class="keyword">typename</span> From&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> To <span class="title">implicit_cast</span><span class="params">(From <span class="keyword">const</span> &amp;f)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//当upcast使用implicit_cast&lt;&gt;，downcast时static_cast&lt;&gt;不再安全，这里使用</span></span></span><br><span class="line"><span class="function"><span class="comment">//dynamic_cast&lt;&gt;来检查downcast是否合法</span></span></span><br><span class="line"><span class="function"><span class="comment">//不支持RTTI，如</span></span></span><br><span class="line"><span class="function"><span class="comment">//if(dynamic_cast&lt;subclass&gt;(foo)) HandleSubclassObj(foo);</span></span></span><br><span class="line">template&lt;typename To, typename From&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> To <span class="title">down_cast</span><span class="params">(From* f)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="StringPiece-h"><a href="#StringPiece-h" class="headerlink" title="StringPiece.h"></a>StringPiece.h</h2><p> 传递C风格的字符串参数给函数，知乎有个相关的提问与回答<a href="https://www.zhihu.com/question/34499426" target="_blank" rel="noopener">点击查看</a>，<code>StringPiece</code>是某公司使用的一个类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringArg</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  StringArg(<span class="keyword">const</span> <span class="keyword">char</span>* str) </span><br><span class="line">  	: str_(str)</span><br><span class="line">  &#123; &#125;</span><br><span class="line">  </span><br><span class="line">  StringArg(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str) </span><br><span class="line">  	: str_(str.c_str())</span><br><span class="line">  &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> str_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* str_;</span><br></pre></td></tr></table></figure>
<p>提供non-explicit构造函数给使用者，可以传递<code>const char*</code>或<code>string</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MUDUO_BASE_STRINGPIECE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUDUO_BASE_STRINGPIECE_H</span></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringPiece</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>*   ptr_;</span><br><span class="line">  <span class="keyword">int</span>           length_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//default</span></span><br><span class="line">  StringPiece()</span><br><span class="line">  	: ptr_(<span class="literal">NULL</span>), length_(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">  <span class="comment">//参数为字符指针</span></span><br><span class="line">  StringPiece(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span><br><span class="line">    : ptr_(str), length_(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">strlen</span>(ptr_))) &#123; &#125;</span><br><span class="line">  <span class="comment">//参数为无符号字符指针; reinterpret_cast临时隐藏类型，使用时要将其转换为原型</span></span><br><span class="line">  <span class="comment">//具有非常强的转换能力</span></span><br><span class="line">  StringPiece(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* str)</span><br><span class="line">    : ptr_(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(str)),</span><br><span class="line">      length_(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">strlen</span>(ptr_))) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  StringPiece(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span><br><span class="line">    : ptr_(str.data()), length_(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(str.size())) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">  StringPiece(<span class="keyword">const</span> <span class="keyword">char</span>* offset, <span class="keyword">int</span> len)</span><br><span class="line">    : ptr_(offset), length_(len) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//string类常见成员</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> length_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> length_ == <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptr_ + length_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; ptr_ = <span class="literal">NULL</span>; length_ = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* buffer, <span class="keyword">int</span> len)</span> </span>&#123; ptr_ = buffer; length = len; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123; </span><br><span class="line">  	ptr = str;</span><br><span class="line">  	length_ = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">strlen</span>(str)); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//运算符成员函数[], ==,</span></span><br><span class="line">  <span class="keyword">char</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> _ptr[i]; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> StringPiece&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> (x.length_ == length_) &amp;&amp;</span><br><span class="line">  		   (<span class="built_in">memcmp</span>(x.ptr_, ptr_, length_) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> StringPiece&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> !(*<span class="keyword">this</span> == x);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//比较成员函数</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> StringPiece&amp; x)</span> <span class="keyword">const</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="comment">//转换成string类型</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">as_string</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">CopyToString</span><span class="params">(<span class="built_in">string</span>* target)</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="comment">//判断起始字符</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">start_with</span><span class="params">(<span class="keyword">const</span> StringPiece&amp; x)</span> <span class="keyword">const</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace muduo</span></span><br><span class="line">  <span class="comment">//允许String Pieces被记录到日志中</span></span><br><span class="line">  <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream o&amp;, <span class="keyword">const</span> muduo::StringPieces piece);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h1 id="muduo-net网络库"><a href="#muduo-net网络库" class="headerlink" title="muduo/net网络库"></a>muduo/net网络库</h1><h2 id="Buffer-cc和Buffer-h"><a href="#Buffer-cc和Buffer-h" class="headerlink" title="Buffer.cc和Buffer.h"></a>Buffer.cc和Buffer.h</h2><p><img src="https://img-blog.csdnimg.cn/20200501173424887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9waWppYW5nMjMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1）<strong>特点</strong>：封装vector作为缓冲区，因为vector为一块连续空间，且其本身具有自动增长的性质，迭代器为原始指针，使用起来较为方便<br>2）<strong>分布</strong>：缓冲区分为三个部分<br>prependable：大小为<code>readerIndex</code><br>readable：大小为<code>writerIndex - readerIndex</code><br>writeable：大小为<code>size() - writerIndex</code><br>初始时，readable == 0，readIndex = writeIndex = 8；<br>3）<strong>检索</strong>：Buffer类通过<code>findCRLF</code>和<code>findEOL</code>成员函数在<code>readerable</code>区域检索<code>\r\n</code>和<code>EOL</code><br>4）<strong>调整区域</strong>：</p>
<ul>
<li>通过成员函数<code>hasWritten</code>和<code>unwrite</code>调整可读/可写区域的大小，如果向Buffer写入200字节，那么<code>writeIndex += 200</code>，<code>readable == 200</code>，<code>writable == 824</code>；</li>
<li>成员函数<code>read()</code>和<code>retrieve()</code>读入50字节，<code>readIndex += 50</code>，<code>readable == 150</code>，<code>writable == 824</code>；当一次性读完时，调用<code>retrieveall()</code>将<code>Buffer</code>重置</li>
</ul>
<p>5）<strong>自动增长</strong>：如果客户代码一次性写入1000字节，而当前可写字节小于这个数（prependable+writable），那么buffer就会自动增长以容纳全部数据。<br>6）<strong>内部挪腾</strong>：当可写字节满足需求，但是writable大小不足时，移动readable，腾出位置<br>7）<strong>前方添加</strong>：提供prependable，让程序能以很小的代价在数据前面添加几个字节。比如说要序列化一个消息，但是并不知道消息长度，于是不断append()直到序列化完成，此时可以通过readable区域变化求出消息长度，在prependable中用4个字节存储。<br>8）<strong>读取内容</strong>：利用<code>readfd()</code>，在栈上开辟一块65536字节额外缓冲区，利用readv()来读。注意在muduo中只调用了一次readv来读取数据是因为它采用的是level trigger，而不是edge trigger。如果采用边缘触发，就需要使用一个while循环来不断读取，直到把缓冲区的内容读取完。边缘触发相比水平触发会进行更多次的系统调用，对追求低延迟的程序而言不一定更高效。边缘触发更适合高并发，比如系统中存在很多不需要读写的就绪文件描述符，水平触发每次都会返回不断通知，边缘触发只通知一次，直到有第二次的读写事件发生。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> :</span> <span class="keyword">public</span> muduo::copyable </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//1) 用一个vector来维护一个缓冲区</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; buffer_;</span><br><span class="line">  <span class="keyword">size_t</span> readerIndex_;</span><br><span class="line">  <span class="keyword">size_t</span> writerIndex_;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> kCRLF[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;*buffer_.begin(); &#125;  <span class="comment">//使用vector自身的迭代器,begin()返回缓冲区起始元素</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">beginWrite</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> begin() + writeIndex_; &#125;  <span class="comment">//获得writeable区的起始元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kCheapPrepend = <span class="number">8</span>;  <span class="comment">//定义prepenable初始大小为8</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kInitialSize = <span class="number">1024</span>;  <span class="comment">//定义writeable初始大小为1024</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2) 求缓冲区三个部分的大小</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">readableBytes</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> writerIndex_ - readerIndex_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">writableBytes</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> buffer_.size() - writerIndex_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">prependableBytes</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> readerIndex_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">peek</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> begin() + readerIndex_; &#125;  <span class="comment">//求readerable的头部指针</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//3) 检索"/r/n"和EOL</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">findCRLF</span><span class="params">()</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">  </span>&#123; </span><br><span class="line">  	<span class="keyword">const</span> <span class="keyword">char</span>* crlf = <span class="built_in">std</span>::search(peek(), beginWrite(), kCRLF, kCRLF+<span class="number">2</span>)  <span class="comment">//检索范围是readable区域，搜索的元素范围是[kCRLF,kCRLF+2]</span></span><br><span class="line">  	<span class="keyword">return</span> crlf == beginWrite() ? <span class="literal">NULL</span> : crlf;  <span class="comment">//若search返回尾部迭代器则没有找到</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//重载findCRLF，可以自定义检索起始位置</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">findCRLF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* start)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  	assert(peek() &lt;= start);</span><br><span class="line">  	assert(start &lt;= beginWrite());</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">findEOL</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; ... &#125;  <span class="comment">//在readerable中搜索换行符</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">findEOL</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* start)</span> <span class="keyword">const</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//4) 写入和未写入移动writerIndex来调整可读/可写区域的大小</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">hasWritten</span><span class="params">(<span class="keyword">size_t</span> len)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">	assert(len &lt;= writableBytes());</span><br><span class="line">	writerIndex += len;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unwrite</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    assert(len &lt;= readableBytes());</span><br><span class="line">    writerIndex_ -= len;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//从缓冲区中读取数据</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">retrieve</span><span class="params">(<span class="keyword">size_t</span> len)</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">retrieveAll</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    readerIndex_ = kCheapPrepend;</span><br><span class="line">    writerIndex_ = kCheapPrepend;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ensureWritableBytes(len);</span><br><span class="line">    <span class="built_in">std</span>::copy(data, data+len, beginWrite());</span><br><span class="line">    hasWritten(len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//5) 自动增长</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ensureWritableBytes</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (writableBytes() &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">      makeSpace(len);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(writableBytes() &gt;= len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//6) 内部腾挪</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">makeSpace</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (writableBytes() + prependableBytes() &lt; len + kCheapPrepend)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">FIXME:</span> move readable data</span></span><br><span class="line">      buffer_.resize(writerIndex_+len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// move readable data to the front, make space inside buffer</span></span><br><span class="line">      assert(kCheapPrepend &lt; readerIndex_);</span><br><span class="line">      <span class="keyword">size_t</span> readable = readableBytes();</span><br><span class="line">      <span class="comment">//std::copy(first, last, destfirst) 要拷贝元素的首地址、尾地址和拷贝目的地首地址</span></span><br><span class="line">      <span class="built_in">std</span>::copy(begin()+readerIndex_,</span><br><span class="line">                begin()+writerIndex_,</span><br><span class="line">                begin()+kCheapPrepend);</span><br><span class="line">      readerIndex_ = kCheapPrepend;</span><br><span class="line">      writerIndex_ = readerIndex_ + readable;</span><br><span class="line">      assert(readable == readableBytes());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8) 读取内容</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Buffer::readFd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span>* savedErrno)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> extrabuf[<span class="number">65536</span>];  <span class="comment">//在栈上开辟一块额外的缓冲区</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">vec</span>[2];</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> writable = writableBytes();</span><br><span class="line">  <span class="comment">//iovec第一块指向buffer中的writable，第二块指向extrabuf</span></span><br><span class="line">  vec[<span class="number">0</span>].iov_base = begin()+writerIndex_;</span><br><span class="line">  vec[<span class="number">0</span>].iov_len = writable;</span><br><span class="line">  vec[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">  vec[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span> extrabuf;</span><br><span class="line">  <span class="comment">//当空间足够时，即 n &lt; writable，不使用extrabuf</span></span><br><span class="line">  <span class="comment">//否则读到extrabuf，然后再把extrabuf中的数据append()到Buffer中</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> iovcnt = (writable &lt; <span class="keyword">sizeof</span> extrabuf) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">ssize_t</span> n = sockets::readv(fd, vec, iovcnt);  <span class="comment">//readv返回读到的总字节数n</span></span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    *savedErrno = errno;  <span class="comment">//存储异常</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (implicit_cast&lt;<span class="keyword">size_t</span>&gt;(n) &lt;= writable)</span><br><span class="line">  &#123;</span><br><span class="line">    writerIndex_ += n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    writerIndex_ = buffer_.size();</span><br><span class="line">    append(extrabuf, n - writable);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/05/08/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/08/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">约瑟夫环问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-08 22:23:25" itemprop="dateCreated datePublished" datetime="2020-05-08T22:23:25+08:00">2020-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-11 15:05:50" itemprop="dateModified" datetime="2020-05-11T15:05:50+08:00">2020-05-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>约瑟夫环来源于犹太历史学家Josephus所讲述的一个故事。罗马人占领某地后，39个犹太人和Josephus以及他的朋友躲到了一个洞中。<br>他们决定围成一个圈，逐个自杀也不要被罗马人抓住。自杀规则是从第一个人开始，数到3的人就自杀，然后由下一个人重新报数。<br>Josephus和他的朋友不想自杀，他们自己选择了两个位置，活到了最后。</p>
<p>将这个问题抽象以后，在LeetCode上有这么一道题<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">圆圈中最后剩下的数字</a><br>在我做笔试的经历中，出现了题目的变种，变化之处在于删除的数字间隔是变化的，随着删除个数而增长。</p>
<h1 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h1><h2 id="循环数组（链表）"><a href="#循环数组（链表）" class="headerlink" title="循环数组（链表）"></a>循环数组（链表）</h2><p>题中是一个圈，所以启发我们用一个循环数组或链表来解决这个问题。由于数组需要一整块的内存且删除操作不如链表，本文选则STL库容器list来实现<br>一个环形链表。只需要迭代器每次扫描到链表末尾时，将其移动到链表头部即可。</p>
<p>需要注意的点：</p>
<p>1) 扫描链表时，一定要注意走到<code>list.end()</code>要转移到<code>begin()</code><br>2) <code>list.erase()</code>删除操作，迭代器移动到被删除节点的下一个位置，所以重点关注next节点<br>是否是尾部迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemainNum</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    usigned <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; r_list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        r_list.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">list</span>.begin();</span><br><span class="line">    <span class="keyword">while</span>(r_list.size() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            it++;</span><br><span class="line">            <span class="keyword">if</span>(it == r_list.end())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//m = m+1; 如果m是变化的，可以在这里修改m的数值</span></span><br><span class="line">                it = r_list.begin();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> next = ++it;</span><br><span class="line">        <span class="keyword">if</span>(next == r_list.end())</span><br><span class="line">        &#123;</span><br><span class="line">            next = r_list.begin();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        it--;</span><br><span class="line">        r_list.erase(it);</span><br><span class="line">        it = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数学思路"><a href="#数学思路" class="headerlink" title="数学思路"></a>数学思路</h2><p>我们可以这样考虑</p>
<p>1）剩两个元素时，数数从0开始，是0-&gt;1-&gt;0，0这个位置会被删除，1保留下来；</p>
<p>2）剩下三个元素时，0-&gt;1-&gt;2，0-&gt;1-&gt;0，2和0被删掉，1保留下来；</p>
<p>3) 剩下四个元素，0-&gt;1-&gt;2，3-&gt;0-&gt;1，3-&gt;0-&gt;3，删掉顺序是2，1，3，0保留下来；</p>
<p>4) 剩下五个元素，…，删除顺序是2，0，4，1，3保留下来</p>
<p>乍一看是看不出来规律，但是我们动手算的过程中会发现：</p>
<ul>
<li>假设剩余n个元素(2 &lt;= n)，m个间隔，最终保留的下标是res1 = f(n,m)。</li>
<li>假设对于n+1个数，位置为res2 = f(n+1,m)的数保留；</li>
<li>那么在删除一个元素的过程中，res2的位置和res1有什么关系？</li>
<li></li>
</ul>
<p>此时思路已经相对明显了，我们来尝试进行倒推。<br>f(2,3) = 1;<br>f(3,3) = (f(2,3) + m) % 3; //<br>f(4,3) = (f(3,3) + m) % 4;<br>…<br>f(n,m) = (f(n-1,m) + m) % n</p>
<table>
<thead>
<tr>
<th>人数</th>
<th>位置</th>
<th>间隔</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
<td>3</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/05/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">单例模式学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-08 09:47:36" itemprop="dateCreated datePublished" datetime="2020-05-08T09:47:36+08:00">2020-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-11 15:04:36" itemprop="dateModified" datetime="2020-05-11T15:04:36+08:00">2020-05-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式的精髓是一个类只产生一个实例对象，当对象被构造以后，阻止构造、拷贝构造、赋值和析构操作。<br>单例模式可以考虑以下问题，如线程安全性和如何优化等。本文讨论学习单例模式过程中通过博客和书籍<br>学习到的解决方案。</p>
<h2 id="单线程-饿汉式"><a href="#单线程-饿汉式" class="headerlink" title="单线程(饿汉式)"></a>单线程(饿汉式)</h2><p>保证类仅有一个实例，并提供一个访问它的全局访问点。</p>
<ul>
<li>构造函数私有化，避免外界使用new来创造实例 (思考=delete和设为private的区别在哪里？)</li>
<li>通过判断一个局部static变量来确定是否创造实例</li>
<li>通过接口<code>GetInstance</code>来取得实例</li>
</ul>
<p>由于这种设计方案使用了静态成员，类产生时就创建好了实例对象，也被称作<strong>饿汉模式</strong>，是一种<br>空间换时间的做法。同时饿汉式也是<strong>线程安全</strong>的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* p_instance; <span class="comment">//单例的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() = <span class="keyword">default</span>;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">    ~Singleton() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Singleton() = delete;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p_instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p_instantce;</span><br><span class="line">        p_instance = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化静态成员变量</span></span><br><span class="line">Singleton* Singleton::p_instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出来是线程安全的，而在多线程中，如果采用懒汉模式，需要使用该实例时才创建，可能存在A线程进入if语句后B线程已经实例化一个对象，这样就会产生两个实例，不符合单例模式的需求。</p>
<h2 id="多线程-懒汉模式"><a href="#多线程-懒汉模式" class="headerlink" title="多线程(懒汉模式)"></a>多线程(懒汉模式)</h2><ul>
<li>通过对临界区加锁，避免多个线程同时访问Singleton</li>
<li>避免锁的开销，只有未被实例化时才加锁(双重检查锁)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* p_instance; <span class="comment">//单例的对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex m_mutex;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p_instance == <span class="literal">nullptr</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            lock(m_mutex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p_instance == <span class="literal">nullptr</span>)</span><br><span class="line">                    p_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p_instantce;</span><br><span class="line">        p_instance = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::p_instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex Singleton::m_mutex;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/04/28/TCP%E4%B8%89%E8%B7%AF%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/28/TCP%E4%B8%89%E8%B7%AF%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" class="post-title-link" itemprop="url">TCP三路握手四次挥手</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-28 15:56:10 / Modified: 16:25:13" itemprop="dateCreated datePublished" datetime="2020-04-28T15:56:10+08:00">2020-04-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>面试时无数次被问到这个知识点，但是回答的时候总是不够特别详尽以及需要面试官再次追问。所以最好一次性就能把所有这块知识点回答完才算是合格的准备。</p>
<h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><h2 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a>TCP三次握手过程</h2><p>客户端一开始处于closed状态，开启三次握手，发送一个SYN给服务端进入SYN_SENT状态，TCP报文中seq的初始值是随着时间而变化的一个值，防止在网络中延迟的分组在以后又被传送导致某一方对它做出错误的解释；服务端接收到SYN后，进入SYN_RECV的状态，延迟一段时间后发送自己的SYN/seq和对客户端SYN的一个确认ACK/ack，报头中确认号的值是seq+1因为ack本身也占了一位，延迟确认可以降低网络流量，以及减少网络中小的报文段；客户端接收到服务端的ack后，发送对服务端SYN的确认，此后双方进入ESTABLISHED状态。</p>
<p>为什么不能是两次握手？TCP三次握手可以进行优化嘛？TCP可以在握手期间传送数据嘛？这其实都是一个问题，就是探讨两次握手会造成什么危害。<br>个人理解的是，TCP两次握手是客户端接收到服务端的SYN和ack双方就默认建立连接。假设服务端之前返回的SYN&amp;ACK报文在网络中遗失，当再次发送给客户端，客户端误以为要建立连接，就直接维护了这个连接，但服务端端并没有数据的传输，浪费了服务器的性能。</p>
<h2 id="SYN洪水攻击"><a href="#SYN洪水攻击" class="headerlink" title="SYN洪水攻击"></a>SYN洪水攻击</h2><p>针对三次握手，而产生的一种攻击方式。客户端和服务器使用TCP协议发起会话时，会在内存中开辟一小块缓冲区来处理会话过程中的消息交换。<br>1）大量虚假ip发送SYN：服务器返回ack找不到地址，触发重传机制<br>2）拦截客户机应答报文：两次握手后，拦截客户端对服务端的应答，服务端收不到ACK会再次发送第二次握手确认报文。</p>
<h1 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h1><p>客户端和服务端双方初始状态为ESTABLISHED，客户端发送一个FIN/seq，进入FIN_WAIT_1状态；服务端接收到FIN后，返回一个ACK/seq+1，表示知道对方要关闭连接，进入CLOSE_WAIT被动关闭状态。等服务端也没有数据需要发送后，会给对端发送一个FIN/seq，表示自己要关闭连接，进入LAST ACK状态；客户端接收到后，返回一个ACK/seq+1进入TIME_WAIT状态，时间为2MSL，避免服务端没有收到此ACK再次发送报文。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yangwq"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">yangwq</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">豫ICP备20013789号 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yangwq</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
