<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ywq1113.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="My Personal Blog">
<meta property="og:url" content="http://ywq1113.github.io/index.html">
<meta property="og:site_name" content="My Personal Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yangwq">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://ywq1113.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-cn'
  };
</script>

  <title>My Personal Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">My Personal Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/06/19/CSAPP%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/19/CSAPP%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" class="post-title-link" itemprop="url">CSAPP优化程序性能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-19 16:49:06 / Modified: 16:57:47" itemprop="dateCreated datePublished" datetime="2020-06-19T16:49:06+08:00">2020-06-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="优化程序性能"><a href="#优化程序性能" class="headerlink" title="优化程序性能"></a>优化程序性能</h1><p>来源于CSAPP第五章</p>
<h2 id="消除不必要的内存引用"><a href="#消除不必要的内存引用" class="headerlink" title="消除不必要的内存引用"></a>消除不必要的内存引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以设计不同的数据类型来测量程序性能</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">data_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> len;</span><br><span class="line">    <span class="keyword">data_t</span> *data;</span><br><span class="line">&#125; vec_rec, *vec_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设计对数据执行不同的运算</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDENT 0  <span class="comment">//求和，如果是求乘积设为1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OP +  <span class="comment">//如果求乘积设为*</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combin3</span><span class="params">(vec_ptr v, <span class="keyword">data_t</span>* dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">long</span> length = vec_length(v);  <span class="comment">//减少循环中的函数调用</span></span><br><span class="line">    <span class="keyword">data_t</span>* data = get_vec_start(v);  <span class="comment">//减少过程调用的优化</span></span><br><span class="line"></span><br><span class="line">    *dest = IDENT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        *dest = *dest OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的汇编码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># vmovsd代表从指定的位置读数据</span><br><span class="line">.L17:                    # loop:</span><br><span class="line">vmovsd  (%rbx), %xmm0    # Read product from dest          指针dest的地址从%xmm0读出来，存在寄存器%rbx中</span><br><span class="line">vmulsd  (%rdx), %xmm0    # Multiply product by data[i]     第i个元素的指针保存在%rdx中</span><br><span class="line">vmovsd  %xmm0, (%rbx)    # Store product at dest           将rbx中的数据读出，存入%xmm0中</span><br><span class="line">addq    $8, %rdx         # Increment data + i</span><br><span class="line">cmpq    %rax, %rdx       # Compare to data+length          data+length存放在%rax中</span><br><span class="line">jne     .L17             # If !&#x3D;, goto loop</span><br></pre></td></tr></table></figure>

<p>进入循环后，从内存中读数据，和<code>data[i]</code>乘，再写入到内存中。这种操作比较浪费，因为循环下次读的数据是上次写入内存的数据。</p>
<p>可以用一个临时变量来存储结果，等循环结束后再写入内存中。这样每次循环可以减少一次写的过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combin4</span><span class="params">(vec_ptr v, <span class="keyword">data_t</span>* dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">long</span> length = vec_length(v);  </span><br><span class="line">    <span class="keyword">data_t</span>* data = get_vec_start(v);  </span><br><span class="line">    <span class="keyword">data_t</span> acc = IDENT;  <span class="comment">//temp variable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *data = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，从代码层面看指令是一条一条执行的，但是实际处理器中是同时对多条指令求值，这种现象称为指令级并行。所以这两种操作限制了程序的瓶颈：第一个是指令必须按照严格顺序执行，那就会遇到延迟界限；第二个是吞吐量界限（取决于处理器原始计算能力）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/06/09/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%BF%BD%E8%B8%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/09/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%BF%BD%E8%B8%AA/" class="post-title-link" itemprop="url">Linux高并发服务器内存泄漏追踪转载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-09 22:43:24" itemprop="dateCreated datePublished" datetime="2020-06-09T22:43:24+08:00">2020-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-19 22:20:36" itemprop="dateModified" datetime="2020-06-19T22:20:36+08:00">2020-06-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>看了一篇博客，个人感觉很有帮助，目前转载过来留存，正在征询作者意见，如果不同意就删掉啦。</p>
<p>原文链接：<a href="https://blog.csdn.net/kenanxiuji/article/details/48547285" target="_blank" rel="noopener">https://blog.csdn.net/kenanxiuji/article/details/48547285</a></p>
<p>最近，我一直忙于追踪分析，咱公司高并发代理服务器内存一直占用过高的问题。该问题表现如下，使用python脚本压测，服务器使用的物理内存一直飙升很快上G、虚拟内存更是高达数10G，没有下降的趋势。当压测程序停止运行后，整个服务占用的物理内存以及虚拟内存并没有下降的趋势。</p>
<p>首先简诉咱服务器运行的平台是centos-6.3（linux-2.6.32），该服务器是多进程的，基于libevent网络通信框架，以bufferevent为核心，并使用google::protobuf通信协议进行数据传输。</p>
<p>根据top -p /pmap -dx 等命令，检测出咱服务器进程内存占用很高，我揣测产生了内存泄露。内存泄露有两种，第一种是进程一直持有不在需要或者使用的内存，这不是狭义的内存泄露，因为没有野指针的产生，可以归为广义的内存泄露，这是危害最大的，也是很难捕捉的内存泄露，使用valgrind等工具是没有办法检测出来的；第二种是进程通过malloc、new分配了堆内存，却由于各种原因，未能释放，这是狭义的内存泄露，可以通过valgrind等内存泄露工具检测到的。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/09/Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%BF%BD%E8%B8%AA/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/06/09/CentOS7%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5mysqlclient/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/09/CentOS7%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5mysqlclient/" class="post-title-link" itemprop="url">CentOS7无法连接mysqlclient</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-09 18:46:33 / Modified: 18:52:35" itemprop="dateCreated datePublished" datetime="2020-06-09T18:46:33+08:00">2020-06-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在makefile中用了<code>-lmysqlclient</code>,但是会报错<code>/usr/bin/ld: cannot find -lmysqlclient</code>。</p>
<p>先在/user/lib中查，发现没有，用find / -name mysqlclient发现也没有。</p>
<p>于是借助搜索引擎去查，结果国内论坛怎么也没找到解决办法，不得已去看官方C API，发现让重新下载解压，遂放弃。</p>
<p>随后又在stack overflow搜索了一下，果不其然，成功解决。附上解决方案：<a href="https://stackoverflow.com/questions/15958612/libmysqlclient-a-is-nowhere-to-be-found" target="_blank" rel="noopener">https://stackoverflow.com/questions/15958612/libmysqlclient-a-is-nowhere-to-be-found</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/06/08/%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/08/%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/" class="post-title-link" itemprop="url">缓存读写一致性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-08 17:54:22 / Modified: 17:57:26" itemprop="dateCreated datePublished" datetime="2020-06-08T17:54:22+08:00">2020-06-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="缓存读写一致性问题"><a href="#缓存读写一致性问题" class="headerlink" title="缓存读写一致性问题"></a>缓存读写一致性问题</h1><p>在知乎看（搜索）到这么一个问题：如何用redis/memcache做Mysql缓存层？刚好最近学的项目只是用到了mysql，这里学习整理一下缓存的知识。PS：强烈建议学习陈皓大神的文章以及阅读英文原文，中文博客知识需要进行筛选。</p>
<p>知乎问题<a href="https://www.zhihu.com/question/27738066" target="_blank" rel="noopener">https://www.zhihu.com/question/27738066</a></p>
<p>陈皓(左耳朵耗子)的文章<a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">https://coolshell.cn/articles/17416.html</a></p>
<p>首先要讨论的是，缓存删除还是更新的问题。<strong>什么情况下选择删除，什么情况下选择更新</strong>？</p>
<ul>
<li><p>缓存存储的value是序列化的对象</p>
<p>  序列化和反序列化需要消耗cpu的资源，删除缓存成本更低，等出现下次数据汇源时再更新。</p>
</li>
<li><p>高并发的场景</p>
<p>  两个并发操作，一个查询缓存，一个更新操作。先更新（选择删除缓存），再查询，此时无法命中缓存，会先把老的数据从数据库读出放入缓存中，然后更新数据库。此时缓存中是脏的数据，并且一直这样脏下去。所以，这种场景应该选择缓存更新，而不是删除Cache后再从数据库更新。</p>
</li>
</ul>
<h2 id="更新缓存的四种模式"><a href="#更新缓存的四种模式" class="headerlink" title="更新缓存的四种模式"></a>更新缓存的四种模式</h2><h3 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h3><p>缓存预留模式，最常用的模式之一。这种模式的重点在于先把数据更新到数据库，成功后让缓存失效，最后更新缓存。</p>
<p>在并发的情况下，更新前查询缓存命中，此时是老数据，更新过程中查询只有两种情况：1）更新过程中命中缓存，获取脏数据，之后再查询都是新的数据；2）更新后让缓存失效，此时查询无法命中缓存，直接从数据库获取新的数据。</p>
<p>这样不会出现上面谈到的缓存中总是脏数据的逻辑问题。但是也不代表这种做法是稳定安全的。如果在读数据的过程没有命中缓存，同时有一个并发写的操作，读操作从数据库得到脏数据，数据库更新，之前的读操作再把老的数据放进去，就会造成脏数据。</p>
<p>总结：Facebook采用这种做法，是选择将脏数据概率降至最低，而不是选择成本较高的2PC和Paxos分布式一致性协议保证数据的一致性。</p>
<h3 id="Read-Write-Through-Pattern"><a href="#Read-Write-Through-Pattern" class="headerlink" title="Read/Write Through Pattern"></a>Read/Write Through Pattern</h3><p>Read/Write through模式（直写模式）是把更新数据库的操作，交给缓存，认为后端是一个单一的存储，这个存储维护自己的Cache，对应用层很友好。</p>
<p>缺点：相比write back模式，数据修改时同时写入数据库，写入速度慢。</p>
<ul>
<li><p><strong>Read Through</strong></p>
<p>  在查询/读操作中更新缓存，缓存失效时服务自己从数据库中加载。</p>
</li>
<li><p><strong>Write Through</strong></p>
<p>  和Read Through相仿，区别在于是在更新/写数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）。</p>
</li>
</ul>
<h3 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h3><p>也称作write back回写模式。在数据更新时只写入缓存Cache。只有数据被替换出缓存时，被修改的缓存数据才会写到后端存储。</p>
<p>优点：写入速度快，不需要同步写到数据库中；异步操作也可以合并对同一个数据的多次操作，提高性能。</p>
<p>缺点：一旦更新后的数据未被写入存储时，出现系统断电的现象，数据无法找回。</p>
<p>write back流程图：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20200608/569886209_1591610186458_4A47A0DB6E60853DEDFCFDF08A5CA249" alt="图片说明" title="图片标题"> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/06/08/unordered-map%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/08/unordered-map%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">unordered_map使用自定义键类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-08 16:26:51 / Modified: 16:28:32" itemprop="dateCreated datePublished" datetime="2020-06-08T16:26:51+08:00">2020-06-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="unordered-map定义-C-11"><a href="#unordered-map定义-C-11" class="headerlink" title="unordered_map定义(C++11)"></a>unordered_map定义(C++11)</h1><p><a href="https://blog.csdn.net/y109y/article/details/82669620#3.1" target="_blank" rel="noopener">参考博客</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Hash</span> = <span class="title">std</span>:</span>:hash&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">KeyEqual</span> = <span class="title">std</span>:</span>:equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> Key, T&gt; &gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">unordered_map</span>;</span></span><br></pre></td></tr></table></figure>

<p>Key代表键值（key），T是根据哈希函数得到的值（value），Hash是哈希函数的函数对象，KeyEqual是等比函数的函数对象，通过<code>&quot;==&quot;</code>来判断两个key是否相等。<br>想实现自定义的键类型，必须实现hash函数和等比函数。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>法一：利用std::function中的默认hash函数std::hash</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mypair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> first;</span><br><span class="line">    <span class="keyword">char</span> second;</span><br><span class="line"></span><br><span class="line">    mypair(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( a &lt; b)</span><br><span class="line">        &#123;</span><br><span class="line">            first = a;</span><br><span class="line">            second = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            first = b;</span><br><span class="line">            second = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> mypair&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs.first == <span class="keyword">this</span>-&gt;first &amp;&amp; rhs.second == <span class="keyword">this</span>-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">mypair_hash</span><span class="params">(<span class="keyword">const</span> mypair&amp; tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash&lt;<span class="keyword">char</span>&gt;()(tmp.first) ^ hash&lt;<span class="keyword">char</span>&gt;()(tmp.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ERRO: unordered_map&lt;mypair, int, decltype(&amp;mypair_hash)&gt; ids;</span></span><br><span class="line">    <span class="comment">//ERRO: unordered_map&lt;mypair, int, mypair_hash&gt; ids(100, mypair_hash );</span></span><br><span class="line">    <span class="comment">//OK: unordered_map&lt;mypair, int, decltype(&amp;mypair_hash)&gt; ids(100, mypair_hash );</span></span><br><span class="line">    unordered_map&lt;mypair, int, decltype(&amp;mypair_hash)&gt; memo(20/*, mypair_hash*/);  //在这里decltype后面必须要使用引用</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * code</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<p>1) decltype(exp)推导的内容如果是一个左值，那么 decltype(exp) 的类型就是 exp 的引用。在这里mypair_hash是一个函数，如果是自动推导得到的是函数的返回值，不是引用类型，运行时编译器会报错，在hashtable_policy.h中：<br><code>field &#39;std::__detail::_Hashtable_ebo_helper&lt;1, long long unsigned int(const mypair&amp;), false&gt;::_M_tp&#39; invalidly declared function type</code></p>
<p>2) 参考的博客中说memo初始化时必须传入mypair_hash构造函数，但是我尝试不传入发现也是可以编译通过和运行的。</p>
<ul>
<li>法二：重载operator()类，打包哈希函数变成函数对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mypair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> first;</span><br><span class="line">    <span class="keyword">char</span> second;</span><br><span class="line"></span><br><span class="line">    mypair(<span class="keyword">const</span> <span class="keyword">char</span>&amp; a, <span class="keyword">const</span> <span class="keyword">char</span>&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        first = a;</span><br><span class="line">        second = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> mypair&amp; rhs) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs.first == first &amp;&amp; rhs.second == second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashname</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> mypair&amp; tmp)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (hash&lt;<span class="keyword">char</span>&gt;()(tmp.first)) ^ (hash&lt;<span class="keyword">char</span>&gt;()(tmp.second));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_map&lt;mypair, int, hashname&gt; memo(20);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * code</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以直接运行通过，没有什么坑。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/05/24/malloc%E5%92%8Calloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/24/malloc%E5%92%8Calloc/" class="post-title-link" itemprop="url">malloc和alloc</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-24 21:33:33 / Modified: 21:53:53" itemprop="dateCreated datePublished" datetime="2020-05-24T21:33:33+08:00">2020-05-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="malloc和alloc"><a href="#malloc和alloc" class="headerlink" title="malloc和alloc"></a>malloc和alloc</h1><p>在网上找到的转载的英文资料，附上自己的一些理解<a href="https://blog.csdn.net/missuever/article/details/540045" target="_blank" rel="noopener">点击连接</a></p>
<p>Both the <code>malloc()</code> and the <code>calloc()</code> functions are used to allocate dynamic memory. Each operates slightly different from the other.</p>
<p>malloc和calloc函数都用来分配动态内存，他们之间的差别很小</p>
<p><code>malloc()</code> takes a size and returns a pointer to a chunk of memory at least that big: </p>
<p><code>void *malloc( size_t size );</code></p>
<p>malloc返回至少有申请内存大小的一块内存（可能更大）</p>
<p><code>calloc()</code> takes a number of elements, and the size of each, and returns a pointer to a chunk of memoryat least big enough to hold them all:</p>
<p><code>void *calloc( size_t numElements, size_t sizeOfElement );</code></p>
<p>calloc返回至少有多块内存大小之和的内存（可能更大）</p>
<p>There are one major difference and one minor difference between the two functions. The major difference is that <code>malloc()</code> does not initialize the allocated memory. The first time <code>malloc()</code> gives you a particular chunk of memory, the memory might be full of zeros. If memory has been allocated, freed, and reallocated, it probably has whatever junk was left in it. That means, unfortunately, that a program might run in simple cases (when memory is never reallocated) but break when used harder (and when memory is reused).</p>
<p>他们之间最主要的差别是，malloc不初始化分配的内存，可能内存中充满的是零。如果内存已经被分配、释放或重新分配过，它可能存放着未知的内容。这意味着当这块内存从申请，修改，再到被重新分配，包含未知的内容会导致程序崩溃</p>
<p><code>calloc()</code> fills the allocated memory with all zero bits. That means that anything there you are going to use as a char or an int of any length, signed or unsigned, is guaranteed to be zero. Anything you are going to use as a pointer is set to all zero bits. That is usually a null pointer, but it is not guaranteed.Anything you are going to use as a float or double is set to all zero bits; that is a floating-point zero on some types of machines, but not on all.</p>
<p>calloc()用0 bits填充分配的内存，所以不需要初始化。通常这是一个空指针，但并不保证一定是。使用float或double类型被置为zero bits，在某些机器上是浮点零，但不保证一定是。</p>
<p>The minor difference between the two is that <code>calloc()</code> returns an array of objects; <code>malloc()</code> returns one object. Some people use <code>calloc()</code> to make clear that they want an array.</p>
<p>一些细小差别是calloc()返回一个包含对象的数组，而malloc返回一个对象。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/05/09/muduo%E5%BA%93%E6%BA%90%E7%A0%81Buffer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/09/muduo%E5%BA%93%E6%BA%90%E7%A0%81Buffer/" class="post-title-link" itemprop="url">muduo库源码Buffer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-09 15:12:25" itemprop="dateCreated datePublished" datetime="2020-05-09T15:12:25+08:00">2020-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-14 12:50:30" itemprop="dateModified" datetime="2020-05-14T12:50:30+08:00">2020-05-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Buffer的功能需求"><a href="#Buffer的功能需求" class="headerlink" title="Buffer的功能需求"></a>Buffer的功能需求</h1><p>设计buffer可以从易用性和性能两方面考虑，muduo的buffer更偏向于易用性。</p>
<ul>
<li>对外表现是一块连续的内存<code>(char* p, int len)</code></li>
<li>其<code>size()</code>可以自动增长，不是固定大小的数组</li>
<li>内部以<code>std::vector&lt;int&gt;</code>来保存数据</li>
<li>buffer更像一个queue，从尾部写入数据，从头部读取数据</li>
<li><code>input buffer</code>：连接从socket中读取数据，写入<code>input buffer</code>；客户代码从中读取数据</li>
<li><code>output buffer</code>：客户代码把数据写入<code>output buffer</code>，连接从<code>output buffer</code>中读数据并写入socket</li>
</ul>
<h1 id="muduo-base基础库"><a href="#muduo-base基础库" class="headerlink" title="muduo/base基础库"></a>muduo/base基础库</h1><p>在学习muduo如何实现Buffer之前，先阅读<code>Buffer.h</code>头文件中所需要的依赖。</p>
<h2 id="types-h"><a href="#types-h" class="headerlink" title="types.h"></a>types.h</h2><p>基本类型的声明，如<code>muduo::string</code>；<br>具体有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">memZero</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为static_cast&lt;&gt;或const_cast&lt;&gt;的安全版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> To, <span class="keyword">typename</span> From&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> To <span class="title">implicit_cast</span><span class="params">(From <span class="keyword">const</span> &amp;f)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//当upcast使用implicit_cast&lt;&gt;，downcast时static_cast&lt;&gt;不再安全，这里使用</span></span></span><br><span class="line"><span class="function"><span class="comment">//dynamic_cast&lt;&gt;来检查downcast是否合法</span></span></span><br><span class="line"><span class="function"><span class="comment">//不支持RTTI，如</span></span></span><br><span class="line"><span class="function"><span class="comment">//if(dynamic_cast&lt;subclass&gt;(foo)) HandleSubclassObj(foo);</span></span></span><br><span class="line">template&lt;typename To, typename From&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> To <span class="title">down_cast</span><span class="params">(From* f)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="StringPiece-h"><a href="#StringPiece-h" class="headerlink" title="StringPiece.h"></a>StringPiece.h</h2><p> 传递C风格的字符串参数给函数，知乎有个相关的提问与回答<a href="https://www.zhihu.com/question/34499426" target="_blank" rel="noopener">点击查看</a>，<code>StringPiece</code>是某公司使用的一个类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringArg</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  StringArg(<span class="keyword">const</span> <span class="keyword">char</span>* str) </span><br><span class="line">  	: str_(str)</span><br><span class="line">  &#123; &#125;</span><br><span class="line">  </span><br><span class="line">  StringArg(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str) </span><br><span class="line">  	: str_(str.c_str())</span><br><span class="line">  &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> str_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* str_;</span><br></pre></td></tr></table></figure>
<p>提供non-explicit构造函数给使用者，可以传递<code>const char*</code>或<code>string</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MUDUO_BASE_STRINGPIECE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUDUO_BASE_STRINGPIECE_H</span></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringPiece</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>*   ptr_;</span><br><span class="line">  <span class="keyword">int</span>           length_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//default</span></span><br><span class="line">  StringPiece()</span><br><span class="line">  	: ptr_(<span class="literal">NULL</span>), length_(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">  <span class="comment">//参数为字符指针</span></span><br><span class="line">  StringPiece(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span><br><span class="line">    : ptr_(str), length_(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">strlen</span>(ptr_))) &#123; &#125;</span><br><span class="line">  <span class="comment">//参数为无符号字符指针; reinterpret_cast临时隐藏类型，使用时要将其转换为原型</span></span><br><span class="line">  <span class="comment">//具有非常强的转换能力</span></span><br><span class="line">  StringPiece(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* str)</span><br><span class="line">    : ptr_(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(str)),</span><br><span class="line">      length_(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">strlen</span>(ptr_))) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  StringPiece(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span><br><span class="line">    : ptr_(str.data()), length_(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(str.size())) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">  StringPiece(<span class="keyword">const</span> <span class="keyword">char</span>* offset, <span class="keyword">int</span> len)</span><br><span class="line">    : ptr_(offset), length_(len) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//string类常见成员</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> length_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> length_ == <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptr_ + length_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; ptr_ = <span class="literal">NULL</span>; length_ = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* buffer, <span class="keyword">int</span> len)</span> </span>&#123; ptr_ = buffer; length = len; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123; </span><br><span class="line">  	ptr = str;</span><br><span class="line">  	length_ = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">strlen</span>(str)); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//运算符成员函数[], ==,</span></span><br><span class="line">  <span class="keyword">char</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> _ptr[i]; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> StringPiece&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> (x.length_ == length_) &amp;&amp;</span><br><span class="line">  		   (<span class="built_in">memcmp</span>(x.ptr_, ptr_, length_) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> StringPiece&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> !(*<span class="keyword">this</span> == x);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//比较成员函数</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> StringPiece&amp; x)</span> <span class="keyword">const</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="comment">//转换成string类型</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">as_string</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">CopyToString</span><span class="params">(<span class="built_in">string</span>* target)</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="comment">//判断起始字符</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">start_with</span><span class="params">(<span class="keyword">const</span> StringPiece&amp; x)</span> <span class="keyword">const</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace muduo</span></span><br><span class="line">  <span class="comment">//允许String Pieces被记录到日志中</span></span><br><span class="line">  <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream o&amp;, <span class="keyword">const</span> muduo::StringPieces piece);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h1 id="muduo-net网络库"><a href="#muduo-net网络库" class="headerlink" title="muduo/net网络库"></a>muduo/net网络库</h1><h2 id="Buffer-cc和Buffer-h"><a href="#Buffer-cc和Buffer-h" class="headerlink" title="Buffer.cc和Buffer.h"></a>Buffer.cc和Buffer.h</h2><p><img src="https://img-blog.csdnimg.cn/20200501173424887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9waWppYW5nMjMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1）<strong>特点</strong>：封装vector作为缓冲区，因为vector为一块连续空间，且其本身具有自动增长的性质，迭代器为原始指针，使用起来较为方便<br>2）<strong>分布</strong>：缓冲区分为三个部分<br>prependable：大小为<code>readerIndex</code><br>readable：大小为<code>writerIndex - readerIndex</code><br>writeable：大小为<code>size() - writerIndex</code><br>初始时，readable == 0，readIndex = writeIndex = 8；<br>3）<strong>检索</strong>：Buffer类通过<code>findCRLF</code>和<code>findEOL</code>成员函数在<code>readerable</code>区域检索<code>\r\n</code>和<code>EOL</code><br>4）<strong>调整区域</strong>：</p>
<ul>
<li>通过成员函数<code>hasWritten</code>和<code>unwrite</code>调整可读/可写区域的大小，如果向Buffer写入200字节，那么<code>writeIndex += 200</code>，<code>readable == 200</code>，<code>writable == 824</code>；</li>
<li>成员函数<code>read()</code>和<code>retrieve()</code>读入50字节，<code>readIndex += 50</code>，<code>readable == 150</code>，<code>writable == 824</code>；当一次性读完时，调用<code>retrieveall()</code>将<code>Buffer</code>重置</li>
</ul>
<p>5）<strong>自动增长</strong>：如果客户代码一次性写入1000字节，而当前可写字节小于这个数（prependable+writable），那么buffer就会自动增长以容纳全部数据。<br>6）<strong>内部挪腾</strong>：当可写字节满足需求，但是writable大小不足时，移动readable，腾出位置<br>7）<strong>前方添加</strong>：提供prependable，让程序能以很小的代价在数据前面添加几个字节。比如说要序列化一个消息，但是并不知道消息长度，于是不断append()直到序列化完成，此时可以通过readable区域变化求出消息长度，在prependable中用4个字节存储。<br>8）<strong>读取内容</strong>：利用<code>readfd()</code>，在栈上开辟一块65536字节额外缓冲区，利用readv()来读。注意在muduo中只调用了一次readv来读取数据是因为它采用的是level trigger，而不是edge trigger。如果采用边缘触发，就需要使用一个while循环来不断读取，直到把缓冲区的内容读取完。边缘触发相比水平触发会进行更多次的系统调用，对追求低延迟的程序而言不一定更高效。边缘触发更适合高并发，比如系统中存在很多不需要读写的就绪文件描述符，水平触发每次都会返回不断通知，边缘触发只通知一次，直到有第二次的读写事件发生。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> :</span> <span class="keyword">public</span> muduo::copyable </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//1) 用一个vector来维护一个缓冲区</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; buffer_;</span><br><span class="line">  <span class="keyword">size_t</span> readerIndex_;</span><br><span class="line">  <span class="keyword">size_t</span> writerIndex_;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> kCRLF[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;*buffer_.begin(); &#125;  <span class="comment">//使用vector自身的迭代器,begin()返回缓冲区起始元素</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">beginWrite</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> begin() + writeIndex_; &#125;  <span class="comment">//获得writeable区的起始元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kCheapPrepend = <span class="number">8</span>;  <span class="comment">//定义prepenable初始大小为8</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kInitialSize = <span class="number">1024</span>;  <span class="comment">//定义writeable初始大小为1024</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2) 求缓冲区三个部分的大小</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">readableBytes</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> writerIndex_ - readerIndex_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">writableBytes</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> buffer_.size() - writerIndex_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">prependableBytes</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> readerIndex_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">peek</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> begin() + readerIndex_; &#125;  <span class="comment">//求readerable的头部指针</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//3) 检索"/r/n"和EOL</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">findCRLF</span><span class="params">()</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">  </span>&#123; </span><br><span class="line">  	<span class="keyword">const</span> <span class="keyword">char</span>* crlf = <span class="built_in">std</span>::search(peek(), beginWrite(), kCRLF, kCRLF+<span class="number">2</span>)  <span class="comment">//检索范围是readable区域，搜索的元素范围是[kCRLF,kCRLF+2]</span></span><br><span class="line">  	<span class="keyword">return</span> crlf == beginWrite() ? <span class="literal">NULL</span> : crlf;  <span class="comment">//若search返回尾部迭代器则没有找到</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//重载findCRLF，可以自定义检索起始位置</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">findCRLF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* start)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  	assert(peek() &lt;= start);</span><br><span class="line">  	assert(start &lt;= beginWrite());</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">findEOL</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; ... &#125;  <span class="comment">//在readerable中搜索换行符</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">findEOL</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* start)</span> <span class="keyword">const</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//4) 写入和未写入移动writerIndex来调整可读/可写区域的大小</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">hasWritten</span><span class="params">(<span class="keyword">size_t</span> len)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">	assert(len &lt;= writableBytes());</span><br><span class="line">	writerIndex += len;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unwrite</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    assert(len &lt;= readableBytes());</span><br><span class="line">    writerIndex_ -= len;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//从缓冲区中读取数据</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">retrieve</span><span class="params">(<span class="keyword">size_t</span> len)</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">retrieveAll</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    readerIndex_ = kCheapPrepend;</span><br><span class="line">    writerIndex_ = kCheapPrepend;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ensureWritableBytes(len);</span><br><span class="line">    <span class="built_in">std</span>::copy(data, data+len, beginWrite());</span><br><span class="line">    hasWritten(len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//5) 自动增长</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ensureWritableBytes</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (writableBytes() &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">      makeSpace(len);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(writableBytes() &gt;= len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//6) 内部腾挪</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">makeSpace</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (writableBytes() + prependableBytes() &lt; len + kCheapPrepend)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">FIXME:</span> move readable data</span></span><br><span class="line">      buffer_.resize(writerIndex_+len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// move readable data to the front, make space inside buffer</span></span><br><span class="line">      assert(kCheapPrepend &lt; readerIndex_);</span><br><span class="line">      <span class="keyword">size_t</span> readable = readableBytes();</span><br><span class="line">      <span class="comment">//std::copy(first, last, destfirst) 要拷贝元素的首地址、尾地址和拷贝目的地首地址</span></span><br><span class="line">      <span class="built_in">std</span>::copy(begin()+readerIndex_,</span><br><span class="line">                begin()+writerIndex_,</span><br><span class="line">                begin()+kCheapPrepend);</span><br><span class="line">      readerIndex_ = kCheapPrepend;</span><br><span class="line">      writerIndex_ = readerIndex_ + readable;</span><br><span class="line">      assert(readable == readableBytes());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8) 读取内容</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Buffer::readFd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span>* savedErrno)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> extrabuf[<span class="number">65536</span>];  <span class="comment">//在栈上开辟一块额外的缓冲区</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">vec</span>[2];</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> writable = writableBytes();</span><br><span class="line">  <span class="comment">//iovec第一块指向buffer中的writable，第二块指向extrabuf</span></span><br><span class="line">  vec[<span class="number">0</span>].iov_base = begin()+writerIndex_;</span><br><span class="line">  vec[<span class="number">0</span>].iov_len = writable;</span><br><span class="line">  vec[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">  vec[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span> extrabuf;</span><br><span class="line">  <span class="comment">//当空间足够时，即 n &lt; writable，不使用extrabuf</span></span><br><span class="line">  <span class="comment">//否则读到extrabuf，然后再把extrabuf中的数据append()到Buffer中</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> iovcnt = (writable &lt; <span class="keyword">sizeof</span> extrabuf) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">ssize_t</span> n = sockets::readv(fd, vec, iovcnt);  <span class="comment">//readv返回读到的总字节数n</span></span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    *savedErrno = errno;  <span class="comment">//存储异常</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (implicit_cast&lt;<span class="keyword">size_t</span>&gt;(n) &lt;= writable)</span><br><span class="line">  &#123;</span><br><span class="line">    writerIndex_ += n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    writerIndex_ = buffer_.size();</span><br><span class="line">    append(extrabuf, n - writable);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/05/08/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/08/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">约瑟夫环问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-08 22:23:25" itemprop="dateCreated datePublished" datetime="2020-05-08T22:23:25+08:00">2020-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-11 15:05:50" itemprop="dateModified" datetime="2020-05-11T15:05:50+08:00">2020-05-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>约瑟夫环来源于犹太历史学家Josephus所讲述的一个故事。罗马人占领某地后，39个犹太人和Josephus以及他的朋友躲到了一个洞中。<br>他们决定围成一个圈，逐个自杀也不要被罗马人抓住。自杀规则是从第一个人开始，数到3的人就自杀，然后由下一个人重新报数。<br>Josephus和他的朋友不想自杀，他们自己选择了两个位置，活到了最后。</p>
<p>将这个问题抽象以后，在LeetCode上有这么一道题<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">圆圈中最后剩下的数字</a><br>在我做笔试的经历中，出现了题目的变种，变化之处在于删除的数字间隔是变化的，随着删除个数而增长。</p>
<h1 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h1><h2 id="循环数组（链表）"><a href="#循环数组（链表）" class="headerlink" title="循环数组（链表）"></a>循环数组（链表）</h2><p>题中是一个圈，所以启发我们用一个循环数组或链表来解决这个问题。由于数组需要一整块的内存且删除操作不如链表，本文选则STL库容器list来实现<br>一个环形链表。只需要迭代器每次扫描到链表末尾时，将其移动到链表头部即可。</p>
<p>需要注意的点：</p>
<p>1) 扫描链表时，一定要注意走到<code>list.end()</code>要转移到<code>begin()</code><br>2) <code>list.erase()</code>删除操作，迭代器移动到被删除节点的下一个位置，所以重点关注next节点<br>是否是尾部迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemainNum</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    usigned <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; r_list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        r_list.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">list</span>.begin();</span><br><span class="line">    <span class="keyword">while</span>(r_list.size() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            it++;</span><br><span class="line">            <span class="keyword">if</span>(it == r_list.end())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//m = m+1; 如果m是变化的，可以在这里修改m的数值</span></span><br><span class="line">                it = r_list.begin();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> next = ++it;</span><br><span class="line">        <span class="keyword">if</span>(next == r_list.end())</span><br><span class="line">        &#123;</span><br><span class="line">            next = r_list.begin();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        it--;</span><br><span class="line">        r_list.erase(it);</span><br><span class="line">        it = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数学思路"><a href="#数学思路" class="headerlink" title="数学思路"></a>数学思路</h2><p>我们可以这样考虑</p>
<p>1）剩两个元素时，数数从0开始，是0-&gt;1-&gt;0，0这个位置会被删除，1保留下来；</p>
<p>2）剩下三个元素时，0-&gt;1-&gt;2，0-&gt;1-&gt;0，2和0被删掉，1保留下来；</p>
<p>3) 剩下四个元素，0-&gt;1-&gt;2，3-&gt;0-&gt;1，3-&gt;0-&gt;3，删掉顺序是2，1，3，0保留下来；</p>
<p>4) 剩下五个元素，…，删除顺序是2，0，4，1，3保留下来</p>
<p>乍一看是看不出来规律，但是我们动手算的过程中会发现：</p>
<ul>
<li>假设剩余n个元素(2 &lt;= n)，m个间隔，最终保留的下标是res1 = f(n,m)。</li>
<li>假设对于n+1个数，位置为res2 = f(n+1,m)的数保留；</li>
<li>那么在删除一个元素的过程中，res2的位置和res1有什么关系？</li>
<li></li>
</ul>
<p>此时思路已经相对明显了，我们来尝试进行倒推。<br>f(2,3) = 1;<br>f(3,3) = (f(2,3) + m) % 3; //<br>f(4,3) = (f(3,3) + m) % 4;<br>…<br>f(n,m) = (f(n-1,m) + m) % n</p>
<table>
<thead>
<tr>
<th>人数</th>
<th>位置</th>
<th>间隔</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
<td>3</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/05/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">单例模式学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-08 09:47:36" itemprop="dateCreated datePublished" datetime="2020-05-08T09:47:36+08:00">2020-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-11 15:04:36" itemprop="dateModified" datetime="2020-05-11T15:04:36+08:00">2020-05-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式的精髓是一个类只产生一个实例对象，当对象被构造以后，阻止构造、拷贝构造、赋值和析构操作。<br>单例模式可以考虑以下问题，如线程安全性和如何优化等。本文讨论学习单例模式过程中通过博客和书籍<br>学习到的解决方案。</p>
<h2 id="单线程-饿汉式"><a href="#单线程-饿汉式" class="headerlink" title="单线程(饿汉式)"></a>单线程(饿汉式)</h2><p>保证类仅有一个实例，并提供一个访问它的全局访问点。</p>
<ul>
<li>构造函数私有化，避免外界使用new来创造实例 (思考=delete和设为private的区别在哪里？)</li>
<li>通过判断一个局部static变量来确定是否创造实例</li>
<li>通过接口<code>GetInstance</code>来取得实例</li>
</ul>
<p>由于这种设计方案使用了静态成员，类产生时就创建好了实例对象，也被称作<strong>饿汉模式</strong>，是一种<br>空间换时间的做法。同时饿汉式也是<strong>线程安全</strong>的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* p_instance; <span class="comment">//单例的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() = <span class="keyword">default</span>;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">    ~Singleton() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Singleton() = delete;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p_instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p_instantce;</span><br><span class="line">        p_instance = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化静态成员变量</span></span><br><span class="line">Singleton* Singleton::p_instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出来是线程安全的，而在多线程中，如果采用懒汉模式，需要使用该实例时才创建，可能存在A线程进入if语句后B线程已经实例化一个对象，这样就会产生两个实例，不符合单例模式的需求。</p>
<h2 id="多线程-懒汉模式"><a href="#多线程-懒汉模式" class="headerlink" title="多线程(懒汉模式)"></a>多线程(懒汉模式)</h2><ul>
<li>通过对临界区加锁，避免多个线程同时访问Singleton</li>
<li>避免锁的开销，只有未被实例化时才加锁(双重检查锁)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* p_instance; <span class="comment">//单例的对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex m_mutex;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p_instance == <span class="literal">nullptr</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            lock(m_mutex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p_instance == <span class="literal">nullptr</span>)</span><br><span class="line">                    p_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p_instantce;</span><br><span class="line">        p_instance = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::p_instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex Singleton::m_mutex;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://ywq1113.github.io/2020/04/28/TCP%E4%B8%89%E8%B7%AF%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yangwq">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Personal Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/28/TCP%E4%B8%89%E8%B7%AF%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" class="post-title-link" itemprop="url">TCP三路握手四次挥手</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-28 15:56:10 / Modified: 16:25:13" itemprop="dateCreated datePublished" datetime="2020-04-28T15:56:10+08:00">2020-04-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>面试时无数次被问到这个知识点，但是回答的时候总是不够特别详尽以及需要面试官再次追问。所以最好一次性就能把所有这块知识点回答完才算是合格的准备。</p>
<h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><h2 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a>TCP三次握手过程</h2><p>客户端一开始处于closed状态，开启三次握手，发送一个SYN给服务端进入SYN_SENT状态，TCP报文中seq的初始值是随着时间而变化的一个值，防止在网络中延迟的分组在以后又被传送导致某一方对它做出错误的解释；服务端接收到SYN后，进入SYN_RECV的状态，延迟一段时间后发送自己的SYN/seq和对客户端SYN的一个确认ACK/ack，报头中确认号的值是seq+1因为ack本身也占了一位，延迟确认可以降低网络流量，以及减少网络中小的报文段；客户端接收到服务端的ack后，发送对服务端SYN的确认，此后双方进入ESTABLISHED状态。</p>
<p>为什么不能是两次握手？TCP三次握手可以进行优化嘛？TCP可以在握手期间传送数据嘛？这其实都是一个问题，就是探讨两次握手会造成什么危害。<br>个人理解的是，TCP两次握手是客户端接收到服务端的SYN和ack双方就默认建立连接。假设服务端之前返回的SYN&amp;ACK报文在网络中遗失，当再次发送给客户端，客户端误以为要建立连接，就直接维护了这个连接，但服务端端并没有数据的传输，浪费了服务器的性能。</p>
<h2 id="SYN洪水攻击"><a href="#SYN洪水攻击" class="headerlink" title="SYN洪水攻击"></a>SYN洪水攻击</h2><p>针对三次握手，而产生的一种攻击方式。客户端和服务器使用TCP协议发起会话时，会在内存中开辟一小块缓冲区来处理会话过程中的消息交换。<br>1）大量虚假ip发送SYN：服务器返回ack找不到地址，触发重传机制<br>2）拦截客户机应答报文：两次握手后，拦截客户端对服务端的应答，服务端收不到ACK会再次发送第二次握手确认报文。</p>
<h1 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h1><p>客户端和服务端双方初始状态为ESTABLISHED，客户端发送一个FIN/seq，进入FIN_WAIT_1状态；服务端接收到FIN后，返回一个ACK/seq+1，表示知道对方要关闭连接，进入CLOSE_WAIT被动关闭状态。等服务端也没有数据需要发送后，会给对端发送一个FIN/seq，表示自己要关闭连接，进入LAST ACK状态；客户端接收到后，返回一个ACK/seq+1进入TIME_WAIT状态，时间为2MSL，避免服务端没有收到此ACK再次发送报文。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yangwq"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">yangwq</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">豫ICP备20013789号 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yangwq</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
